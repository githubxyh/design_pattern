#单例模式：一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

单例模式的各种实现：
#饿汉式：
 * 有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），
提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。
 * 如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，
做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，
这样就能避免在程序运行的时候，再去初始化导致的性能问题。
 * 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），
那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），
我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。

#懒汉式：
 * synchronzed导致并发度很低，
 * 如果这个单例类偶尔会被用到，那这种实现方式还可以接受。
 * 但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。

#双重检测：
在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。

#静态内部类：
只有当调用getInstance()方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance的唯一性、创建过程的线程安全性，都由 JVM 来保证。
所以，这种实现方法既保证了线程安全，又能做到延迟加载。

#枚举实现：
这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。
